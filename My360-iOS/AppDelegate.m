//
//  AppDelegate.m
//  MSPatient
//
//  Generated by AnyPresence, Inc on 2013-02-26
//  Copyright (c) 2013. All rights reserved.
//

#import "AppDelegate.h"
#import "APCustomButtons.h"
#import "NSObject+InterpolateString.h"
#import <APSDK/NSString+Inflections.h>
#import <APSDK/AuthManager.h>
#import <APSDK/AuthManager+Protected.h>
#import <sys/socket.h>
#import <netinet/in.h>
#import <SystemConfiguration/SystemConfiguration.h>
#import "UIColor+APColorExtension.h"
#import "PIKAnalyticsManager.h"
#import <APSDK/User.h>
#import <APSDK/UserProfile+Remote.h>
#import "LoginViewController.h"
#import <APSDK/MissingTreatmentReason.h>
#import <APSDK/Medication+Remote.h>
#import <APSDK/IngestionMethod+Remote.h>
#import <APSDK/TreatmentSchedule+Remote.h>
#import <APSDK/TreatmentType+Remote.h>
#import <APSDK/APObject+Remote.h>
#import <APSDK/DosageUom+Remote.h>
#import <APSDK/APObject+RemoteRelationships.h>
#import "UIView+APViewExtensions.h"
#import "MBProgressHUD.h"
#import <APSDK/LabResultStat+Remote.h>
#import <APSDK/TestType+Remote.h>
#import <APSDK/Mood+Remote.h>
#import <APSDK/Symptom+Remote.h>
#import <APSDK/Ability+Remote.h>
#import <APSDK/SideEffect+Remote.h>
#import <APSDK/Setting+Remote.h>
#import "PikConstants.h"
#import <APSDK/APDataManager.h>
#import "ConfigurationManager.h"
#import "UIStoryboard+Definition.h"
#import "Flurry.h"

// Set your app version: /api/<HerokuAppVersion>/

//Dev
/*********************************
 
 Server Address and Version are now set in configuration.plist
 which is specific to each app/target
 
 ********************************/

//DEV
//NSString * const kAPServerAddress =@"https://peaceful-temple-4206.herokuapp.com";
//NSString * const KAPVersionNumber =@"/api/v69/"; //25

//FH Enviornment
//STAGE
//NSString * const kAPServerAddress =@"https://my360-stage.atpointofcare360.com";
//NSString * const KAPVersionNumber =@"/api/v15/";

//PRODUCTION
//NSString * const kAPServerAddress =@"https://my360-prod.atpointofcare360.com";
//NSString * const KAPVersionNumber =@"/api/v16/";

//RV
//NSString * const kAPServerAddress =@"https://obscure-dawn-3105.herokuapp.com";
//NSString * const KAPVersionNumber =@"/api/v4/";

 //********************************/

//NSString * const kAPServerAddress =@"https://secure-tor-2456.herokuapp.com";
//NSString * const KAPVersionNumber =@"/api/v33/";

//NSString * const kAPServerAddress =@"http://localhost:3000";
//NSString * const KAPVersionNumber =@"/api/v31/";

 //Demo Enviornment
//NSString * const kAPServerAddress = @"https://intense-gorge-7326.herokuapp.com";
//NSString * const KAPVersionNumber =@"/api/v70/";

//Demo 2
//NSString * const kAPServerAddress = @"https://fast-bayou-9134.herokuapp.com";
//NSString * const KAPVersionNumber =@"/api/v25/";

//@"https://radiant-cove-5271.herokuapp.com";
//@"/api/v1/";

//Staging
//https://clinician.atpointofcare.com/my360-staging
//api/v25



@interface AppDelegate ()

+ (void)subscribeToChannel:(NSString *)channel withToken:(NSData *)token;

@end

@implementation AppDelegate
@synthesize apnToken;
@synthesize sessionOpen;

@synthesize scheduleData;
@synthesize treatmentTypeData;
@synthesize treatmentScheduleData;
@synthesize ingestionMethodData;
@synthesize dosageUomData;
@synthesize medicationData;
@synthesize missingTreatmentReasonData;
@synthesize testTypeData;
@synthesize labResultStatusData;
@synthesize moodData;
@synthesize symptomData;
@synthesize abilityData;
@synthesize sideEffectData;
@synthesize needsFowardToTreatmentTaken;


#pragma - Private

+ (void)subscribeToChannel:(NSString *)channel withToken:(NSData *)token {
    
    //NSData *localToken = [NSData dataWithData:token];
    
    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:[[[ConfigurationManager sharedManager] serverAddress] stringByAppendingString: @"/api/push_notification_extension/subscribe"]]];
    
    NSString* userAgent = @"iPhone";
    NSString *params = [[NSString alloc] initWithFormat:@"channel=%@&device_token=%@", channel, token];
    [request setValue:userAgent forHTTPHeaderField:@"User-Agent"];
    [request setHTTPMethod:@"POST"];
    [request setHTTPBody:[params dataUsingEncoding:NSUTF8StringEncoding]];
    (void)[[NSURLConnection alloc] initWithRequest:request delegate:self];
    
    
    // send to PIK dev server
    NSLog(@"attempting PIK apnSubscribe");
    [UserProfile query:@"my_profile" params:nil  async:^(NSArray * objects, NSError * error) {
        if (error) {
            if(ERROR_CODE_401(error)) {
                AppDelegate *app = (AppDelegate *)[[UIApplication sharedApplication] delegate];
                [app showSessionTerminatedAlert];
            }
            else {
                //[self showMessage:[error localizedDescription] ? : @"Error"];
            }
        } else if (objects.count > 0) {
            UserProfile* userProfile =  [objects objectAtIndex:0];
            NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"http://www.projectsinknowledge.com/iPhone/APN/apnSubscribe.cfm"]];
            
            
            NSLog(@"channel=%@&device_token=%@&userFname=%@&userLname=%@&appID=%ld", channel, token, userProfile.firstName, userProfile.lastName, (long)[[[ConfigurationManager sharedManager] appID] integerValue]);
            
            
            NSString* userAgent = @"iPhone";
            NSString *params = [[NSString alloc] initWithFormat:@"channel=%@&device_token=%@&userFname=%@&userLname=%@&appID=%ld", channel, token, userProfile.firstName, userProfile.lastName, (long)[[[ConfigurationManager sharedManager] appID] integerValue]];
            [request setValue:userAgent forHTTPHeaderField:@"User-Agent"];
            [request setHTTPMethod:@"POST"];
            [request setHTTPBody:[params dataUsingEncoding:NSUTF8StringEncoding]];
            (void)[[NSURLConnection alloc] initWithRequest:request delegate:self];
        }
    }];
    

}

+ (NSString*)interpolateString:(NSString*)string {    
    return [NSObject interpolateString:(NSString *)string block:^(NSString * prefix, NSString * value) {
        if ([prefix isEqualToString:@"user"])
            return [[AuthManager defaultManager].currentCredentials value:[value camelizeWithLowerFirstLetter]];
        else
            return @"";
    }];
}


+ (NSString*)interpolateString:(NSString*)string objectInstance:(id)instance {
    return [NSObject interpolateString:(NSString *)string block:^(NSString * prefix, NSString * value) {
        if ([prefix isEqualToString:@"user"])
            return [[AuthManager defaultManager].currentCredentials value:[value camelizeWithLowerFirstLetter]];
        else if (!prefix.length)
            return [instance value:[value camelizeWithLowerFirstLetter]];
        else
            return @"";
    }];
}


- (void)customizeAppearance
{
    
    NSArray *version = [[UIDevice currentDevice].systemVersion componentsSeparatedByString:@"."];
    
    ConfigurationManager *statusManager = [ConfigurationManager sharedManager];
    statusManager.isOS7 = [[version objectAtIndex:0] intValue] >= 7;

    if (statusManager.isOS7) {
        [[UINavigationBar appearance] setBarTintColor:[UIColor navBarBlue]];
        [[UINavigationBar appearance] setTintColor:[UIColor whiteColor]];

        [[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleLightContent];

    }
    else {
        
        UIImage *gradientImage = [[UIImage imageNamed:@"ToolBar.png"] resizableImageWithCapInsets:UIEdgeInsetsMake(0, 0, 0, 0)];
        
        // Set the background image for *all* UINavigationBars
        [[UINavigationBar appearance] setBackgroundImage:gradientImage forBarMetrics:UIBarMetricsDefault];
        [[UINavigationBar appearance] setTintColor:[UIColor darkBlue]]; //so buttons color correctly
    }
    
    
    // Customize the title text for *all* UINavigationBars
    
//            -  MSAA cleanup svaz 11/27/14
//    [[UINavigationBar appearance] setTitleTextAttributes:
//     [NSDictionary dictionaryWithObjectsAndKeys:
//      [UIColor whiteColor],
//      UITextAttributeTextColor,
//      // [UIFont fontWithName:@"HelveticaNeue-Light" size:20],
//      // UITextAttributeFont,
//      nil]];
        
    [[UINavigationBar appearance] setTitleTextAttributes:
     [NSDictionary dictionaryWithObjectsAndKeys:
      [UIColor whiteColor], NSForegroundColorAttributeName,nil]];
    
}


#pragma mark - Connectivity

+(void)showNoConnecttivityAlert {
    [[[UIAlertView alloc] initWithTitle:@"Sorry!" message:@"Network connection is down. Please try again later." delegate:nil cancelButtonTitle:@"OK" otherButtonTitles:nil] show];
}


/* 
 * Connectivity testing code derived from Apple's Reachability Example: http://developer.apple.com/library/ios/#samplecode/Reachability
 */
+ (BOOL)hasConnectivity {
  struct sockaddr_in zeroAddress;
  bzero(&zeroAddress, sizeof(zeroAddress));
  zeroAddress.sin_len = sizeof(zeroAddress);
  zeroAddress.sin_family = AF_INET;

  SCNetworkReachabilityRef reachability = SCNetworkReachabilityCreateWithAddress(kCFAllocatorDefault, (const struct sockaddr*)&zeroAddress);
  if(reachability != NULL) {
    //NetworkStatus retVal = NotReachable;
    SCNetworkReachabilityFlags flags;
    if (SCNetworkReachabilityGetFlags(reachability, &flags)) {
      if ((flags & kSCNetworkReachabilityFlagsReachable) == 0) {
        // if target host is not reachable
        return NO;
      }
      if ((flags & kSCNetworkReachabilityFlagsConnectionRequired) == 0) {
        // if target host is reachable and no connection is required
        //  then we'll assume (for now) that you're on Wi-Fi
        return YES;
      }
      if ((((flags & kSCNetworkReachabilityFlagsConnectionOnDemand ) != 0) ||
           (flags & kSCNetworkReachabilityFlagsConnectionOnTraffic) != 0))
      {
        // ... and the connection is on-demand (or on-traffic) if the
        //     calling application is using the CFSocketStream or higher APIs

        if ((flags & kSCNetworkReachabilityFlagsInterventionRequired) == 0)
        {
          // ... and no [user] intervention is needed
          return YES;
        }
      }
      if ((flags & kSCNetworkReachabilityFlagsIsWWAN) == kSCNetworkReachabilityFlagsIsWWAN) {
        // ... but WWAN connections are OK if the calling application
        //     is using the CFNetwork (CFSocketStream?) APIs.
        return YES;
      }
    }
  }
  return NO;
}

- (void)showSessionTerminatedAlert {
    if (sessionOpen) {
        UIAlertView *alert = [[UIAlertView alloc]init];
        alert.title = @"Session Terminated";
        alert.message = @"You have been logged out due to inactivity. Please log back in to continue.";
        alert.tag = 999;
        alert.delegate = self;
        [alert addButtonWithTitle:@"OK"];
        [alert show];
        sessionOpen = FALSE;
    }
}

-(void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex{
    if (alertView.tag == 999) {
        //UINavigationController *navigationController = (UINavigationController *)self.window.rootViewController;
        UIStoryboard *mainStoryboard = [UIStoryboard mainStoryboard];
        LoginViewController *controller = (LoginViewController *)[mainStoryboard instantiateViewControllerWithIdentifier: @"LoginView"];
        [self.window setRootViewController:controller];
        //[navigationController pushViewController:controller animated:NO];

    }
}


#pragma mark - AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    
    
    
    [APDataManager setDataManager:[[APDataManager alloc] initWithStore:kAPDataManagerStoreInMemory]];
    sessionOpen = FALSE;
    
    [APObject setBaseURL:[NSURL URLWithString:[[[ConfigurationManager sharedManager] serverAddress] stringByAppendingString:[[ConfigurationManager sharedManager] serverVersion]]]];
    
    // Create a AuthManager and set the singin/out URL's
    AuthManager * auth = [AuthManager new];
    auth.signInURL = [NSURL URLWithString:[[[ConfigurationManager sharedManager] serverAddress] stringByAppendingString:@"/auth/password/callback"]];
    auth.signOutURL = [NSURL URLWithString:[[[ConfigurationManager sharedManager] serverAddress] stringByAppendingString:@"/auth/signout"]];
    
    [AuthManager setDefaultManager:auth];
    
    [self customizeAppearance];
    
    // Show network warning if necessary
    if (![[self class] hasConnectivity]) {
        UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"No Internet!" message:@"This application requires an active internet connection to function properly." delegate:nil cancelButtonTitle:@"OK" otherButtonTitles:nil];
        [alert show];
    }
    
    NSUserDefaults *prefs = [NSUserDefaults standardUserDefaults];
    if (![prefs boolForKey:@"RanFirstTime"]) {
        [PIKAnalyticsManager sendAnalyticsToURLWithParams:
         [NSString stringWithFormat:@"installation.cfm?book=%@&udid=%@",
          [[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleName"],
          [NSNumber numberWithInt:0]]];
        [self setUpReferenceDates];
        [prefs setBool:TRUE forKey:@"RanFirstTime"];
        [prefs synchronize];
    }
    
    // Register for push notifications
    [application registerForRemoteNotificationTypes:UIRemoteNotificationTypeBadge| UIRemoteNotificationTypeAlert| UIRemoteNotificationTypeSound];
    
    
    //---------------FLURRY ----------------------
    //init Flurry   -- added svaz 1/23/15
    
    //  optional method that can be used to set the level of Flurry SDK logs to be displayed on the console. The default log level is FlurryLogLevelCriticalOnly.
    [Flurry setCrashReportingEnabled:YES];
    [Flurry setLogLevel:YES];
    
    switch ([[[ConfigurationManager sharedManager] appID] integerValue]) {
        case AAPA:
            // Unique account for AAP
             [Flurry startSession:@"Y7T84Z5YDFWRNVGW3J6S"];
            break;
        case MS:
            // Unique account for MSAA 
            [Flurry startSession:@"3Y9BTDK82LHFPYY49FGR"];
            break;
            
        default:
            // PIK account
            [Flurry startSession:@"498GTHMSB67K8HHC8KPF"];
            break;
    }
    
    // Turn on debugging in STAGE and PROD
    NSRange rangeValue = [[[ConfigurationManager sharedManager] serverAddress] rangeOfString:@"prod" options:NSCaseInsensitiveSearch];

    if (rangeValue.location == NSNotFound) {
        [Flurry setDebugLogEnabled:YES];
    }
 
//---------------END of FLURRY ----------------------    
    
    
    // Handle remote notifications pushed to app on launch.
    NSDictionary* userInfo = [launchOptions objectForKey:UIApplicationLaunchOptionsRemoteNotificationKey];
    if (userInfo) {
        // NSLog(@"Received remote notification: %@", [userInfo objectForKey:@"custom_key"]);
        // UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Received push!" message: [ NSString stringWithFormat:@"%@", [userInfo objectForKey:@"custom_key"] ] delegate:self cancelButtonTitle:nil otherButtonTitles:@"OK",nil];
        // [alert show];
    }
    
    
    
    return YES;
}


- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)newDeviceToken {
    self.apnToken = newDeviceToken;
    //NSLog(@"My token is: %@", newDeviceToken);
    
    [AppDelegate subscribeToChannel:@"global_channel" withToken:newDeviceToken];
}


- (void)application:(UIApplication*)application didFailToRegisterForRemoteNotificationsWithError:(NSError*)error {
    NSLog(@"Failed to get token, error: %@", error);
}

- (void)applicationDidBecomeActive:(UIApplication *)application {
    [PIKAnalyticsManager sendAnalyticsToURLWithParams:[NSString stringWithFormat:@"run.cfm?book=%@&udid=%@&user=%@&restoredFromBackground=TRUE", [[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleName"], [NSNumber numberWithInt:0], ((User *)[AuthManager defaultManager].currentCredentials).id]];
}

- (void)applicationDidEnterBackground:(UIApplication *)application{
        [PIKAnalyticsManager sendAnalyticsToURLWithParams:[NSString stringWithFormat:@"close.cfm?book=%@&user=%@", [[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleName"], ((User *)[AuthManager defaultManager].currentCredentials).id]];
}

- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo
{
    NSDictionary *apsInfo = (NSDictionary *)[userInfo objectForKey:@"aps"];
    int badgeNum = [(NSNumber *)[apsInfo objectForKey:@"badge"] intValue];
    application.applicationIconBadgeNumber = badgeNum;
    if ( application.applicationState == UIApplicationStateActive ) {
        [[NSNotificationCenter defaultCenter] postNotificationName:@"recievedRemoteNotification" object:nil userInfo:userInfo];
        UIAlertView *alert = [[UIAlertView alloc]init];
        alert.title = @"push notification";
        alert.message = [NSString stringWithFormat:@"%@",userInfo];
        [alert addButtonWithTitle:@"OK"];
        [alert show];
    }
    else {
        // application is in the background AND the user tapped the notification.
        //NSLog(@"AppDelegate In Background Received Notification");
        
    }
    if([self.window.rootViewController isKindOfClass:[UITabBarController class]]){
        if (application.applicationIconBadgeNumber > 0)
        [[[[((UITabBarController *)self.window.rootViewController) tabBar] items]objectAtIndex:1] setBadgeValue:[NSString stringWithFormat:@"%ld",(long)application.applicationIconBadgeNumber]];
        else
        [[[[((UITabBarController *)self.window.rootViewController) tabBar] items]objectAtIndex:1] setBadgeValue:nil];
    }
}

#pragma mark - Tab Bar
-(void)setRootTabBar {
    UIStoryboard *storyboard = [UIStoryboard mainStoryboard];
    UITabBarController *tb = [storyboard instantiateViewControllerWithIdentifier:@"tabBarController"];
    [UIView transitionFromView:self.window.rootViewController.view
                        toView:tb.view
                      duration:0.65f
                       options:UIViewAnimationOptionTransitionCurlUp
                    completion:^(BOOL finished){
                        self.window.rootViewController = tb;
                        UIApplication *app = [UIApplication sharedApplication];
                        if (app.applicationIconBadgeNumber > 0)
                            [[[[((UITabBarController *)self.window.rootViewController) tabBar] items]objectAtIndex:1] setBadgeValue:[NSString stringWithFormat:@"%ld",(long)app.applicationIconBadgeNumber]];
                        else
                            [[[[((UITabBarController *)self.window.rootViewController) tabBar] items]objectAtIndex:1] setBadgeValue:nil];
                        app.applicationIconBadgeNumber = 0;
                        
                    }];
}

-(void)setRootLoginController {
    UIStoryboard *storyboard = [UIStoryboard mainStoryboard];
    UIViewController *vc = [storyboard instantiateViewControllerWithIdentifier:@"loginNavController"];

    [UIView transitionFromView:self.window.rootViewController.view
                        toView:vc.view
                      duration:0.65f
                       options:UIViewAnimationOptionTransitionCurlDown
                    completion:^(BOOL finished){
                        self.window.rootViewController = vc;
    }];
}

-(void)loadAllReferenceData {
    [self readTreatmentReferenceData];
    [self readJournalReferenceData];
    [self readLabReferenceData];
    [self readSideEffectReferenceData];
}
-(void)downloadAllReferenceData{
    [self writeTreatmentReferenceData];
    [self writeJournalReferenceData];
    [self writeLabReferenceData];
    [self writeSideEffectReferenceData];
}

-(void)readTreatmentReferenceData {

    NSMutableArray *dataArray = [NSMutableArray arrayWithCapacity:1];
    NSArray *directoryPaths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
    NSString *documentsDirectory = [directoryPaths objectAtIndex:0];
    NSString *filePath;
    NSString *jsonString;
    NSArray *jsonArray;

    
    // MissingTreatmentReasons
    filePath = [[NSString alloc] initWithString: [documentsDirectory stringByAppendingPathComponent:@"missingtreatmentreasons.dat"]];
   // filePath = [[NSBundle mainBundle] pathForResource:@"missingtreatmentreasons" ofType:@"dat"];
    jsonString = [[NSString alloc] initWithContentsOfFile:filePath encoding:NSUTF8StringEncoding error:nil];
    jsonArray = [NSJSONSerialization JSONObjectWithData:[jsonString dataUsingEncoding:NSUTF8StringEncoding] options:0 error:nil];
    
    for (NSDictionary *dictionary in jsonArray){
        
        MissingTreatmentReason *mtr = [MissingTreatmentReason new];
        
        mtr.id = [dictionary objectForKey:@"id"];
        mtr.name = [dictionary objectForKey:@"name"];
        
        [dataArray addObject:mtr];
    }
    
    self.missingTreatmentReasonData = [dataArray copy];
    

    // Medications
    filePath = [[NSString alloc] initWithString: [documentsDirectory stringByAppendingPathComponent:@"medications.dat"]];
   // filePath = [[NSBundle mainBundle] pathForResource:@"medications" ofType:@"dat"];
    jsonString = [[NSString alloc] initWithContentsOfFile:filePath encoding:NSUTF8StringEncoding error:nil];
    jsonArray = [NSJSONSerialization JSONObjectWithData:[jsonString dataUsingEncoding:NSUTF8StringEncoding] options:0 error:nil];
    
    //reset
    [dataArray removeAllObjects];
    
    for (NSDictionary *dictionary in jsonArray){
        
        Medication *med = [Medication new];
        
        med.id = [dictionary objectForKey:@"id"];
        med.name = [dictionary objectForKey:@"name"];
        //med.category = [dictionary objectForKey:@"category"];     //RV New lable on API for SymtomsCat, TestTypeCat and medicationCat comented 6/8/15
        med.medicationCat = [dictionary objectForKey:@"category"];

        [dataArray addObject:med];
    }
    
    // Added to sort by Name insensetively - svaz
    NSSortDescriptor *sortDescriptor;
    sortDescriptor = [[NSSortDescriptor alloc] initWithKey:@"name"
                                                 ascending:YES
                                                  selector:@selector(localizedCaseInsensitiveCompare:)];
    NSArray *sortDescriptors = [NSArray arrayWithObject:sortDescriptor];
    NSArray *sortedArray = [dataArray sortedArrayUsingDescriptors:sortDescriptors];
    
    //end to sort - svaz
    
    self.medicationData = [sortedArray copy];
    

    
    // IngestionMethods
    filePath = [[NSString alloc] initWithString: [documentsDirectory stringByAppendingPathComponent:@"ingestionmethods.dat"]];
  //  filePath = [[NSBundle mainBundle] pathForResource:@"ingestionmethods" ofType:@"dat"];
    jsonString = [[NSString alloc] initWithContentsOfFile:filePath encoding:NSUTF8StringEncoding error:nil];
    jsonArray = [NSJSONSerialization JSONObjectWithData:[jsonString dataUsingEncoding:NSUTF8StringEncoding] options:0 error:nil];
    
    //reset
    [dataArray removeAllObjects];

    for (NSDictionary *dictionary in jsonArray){

        IngestionMethod *im = [IngestionMethod new];
        
        im.id = [dictionary objectForKey:@"id"];
        im.name = [dictionary objectForKey:@"name"];
        
        [dataArray addObject:im];
    }
    self.ingestionMethodData = [dataArray copy];
    
    
    // DosageUOMs
    filePath = [[NSString alloc] initWithString: [documentsDirectory stringByAppendingPathComponent:@"dosageuoms.dat"]];
  //  filePath = [[NSBundle mainBundle] pathForResource:@"dosageuoms" ofType:@"dat"];
    jsonString = [[NSString alloc] initWithContentsOfFile:filePath encoding:NSUTF8StringEncoding error:nil];
    jsonArray = [NSJSONSerialization JSONObjectWithData:[jsonString dataUsingEncoding:NSUTF8StringEncoding] options:0 error:nil];
    
    //reset
    [dataArray removeAllObjects];

    for (NSDictionary *dictionary in jsonArray){

        DosageUom *du = [DosageUom new];
        
        du.id = [dictionary objectForKey:@"id"];
        du.name = [dictionary objectForKey:@"name"];
        
        [dataArray addObject:du];
    }
    
    self.dosageUomData = [dataArray copy];
    
    
    //TreatmentTypes
    filePath = [[NSString alloc] initWithString: [documentsDirectory stringByAppendingPathComponent:@"treatmenttypes.dat"]];
   // filePath = [[NSBundle mainBundle] pathForResource:@"treatmenttypes" ofType:@"dat"];
    jsonString = [[NSString alloc] initWithContentsOfFile:filePath encoding:NSUTF8StringEncoding error:nil];
    jsonArray = [NSJSONSerialization JSONObjectWithData:[jsonString dataUsingEncoding:NSUTF8StringEncoding] options:0 error:nil];

    //reset
    [dataArray removeAllObjects];
    
    for (NSDictionary *dictionary in jsonArray){

        TreatmentType *tt = [TreatmentType new];
        
        tt.id = [dictionary objectForKey:@"id"];
        tt.name = [dictionary objectForKey:@"name"];
        tt.sortId = [dictionary objectForKey:@"sort_id"];
                
        [dataArray addObject:tt];
    }
    
    self.treatmentTypeData = [dataArray copy];
    
    
    //TreatmentSchedules
    filePath = [[NSString alloc] initWithString: [documentsDirectory stringByAppendingPathComponent:@"treatmentschedules.dat"]];
   // filePath = [[NSBundle mainBundle] pathForResource:@"treatmentschedules" ofType:@"dat"];
    jsonString = [[NSString alloc] initWithContentsOfFile:filePath encoding:NSUTF8StringEncoding error:nil];
    jsonArray = [NSJSONSerialization JSONObjectWithData:[jsonString dataUsingEncoding:NSUTF8StringEncoding] options:0 error:nil];
    
    //reset
    [dataArray removeAllObjects];
    
    for (NSDictionary *dictionary in jsonArray){

        TreatmentSchedule *ts = [TreatmentSchedule new];
        
        ts.id = [dictionary objectForKey:@"id"];
        ts.name = [dictionary objectForKey:@"name"];
        ts.sortOrder = [dictionary objectForKey:@"sort_order"];
        ts.timesPerDay = [dictionary objectForKey:@"times_per_day"];
        
        [dataArray addObject:ts];
    }
    
    self.treatmentScheduleData = [dataArray copy];
}


-(void)writeTreatmentReferenceData{
    
    NSError *err = nil;
    NSMutableArray *container = [[NSMutableArray alloc]init];
    
    NSDictionary *params = [NSDictionary dictionary];
    
    NSArray *objs = [MissingTreatmentReason query:@"active_missing_treatments" params:params error:&err];
    for(MissingTreatmentReason *mtr in objs){
        NSMutableDictionary * obj = [[NSMutableDictionary alloc]init];
        [obj setObject:mtr.id forKey:@"id"];
        [obj setObject:mtr.name forKey:@"name"];
        [container addObject:obj];
    }
    NSData *jsonData = [NSJSONSerialization dataWithJSONObject:container options:0 error:&err];
    
    NSArray *dirPaths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
    NSString *docsDir = [dirPaths objectAtIndex:0];
    NSString *databasePath = [[NSString alloc] initWithString: [docsDir stringByAppendingPathComponent:@"missingtreatmentreasons.dat"]];
    [jsonData writeToFile:databasePath atomically:YES];

    container = [[NSMutableArray alloc]init];
    objs = [Medication query:@"active_medications" params:params error:&err];
    for(Medication *med in objs){
        NSMutableDictionary * obj = [[NSMutableDictionary alloc]init];
        [obj setObject:med.id forKey:@"id"];
        [obj setObject:med.name forKey:@"name"];
        //[obj setObject:med.category forKey:@"category"];    //RV New lable on API for SymtomsCat, TestTypeCat and medicationCat comented 6/8/15
        [obj setObject:med.medicationCat forKey:@"category"];
        [container addObject:obj];
    }
    jsonData = [NSJSONSerialization dataWithJSONObject:container options:0 error:&err];
    
    dirPaths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
    docsDir = [dirPaths objectAtIndex:0];
    databasePath = [[NSString alloc] initWithString: [docsDir stringByAppendingPathComponent:@"medications.dat"]];
    [jsonData writeToFile:databasePath atomically:YES];
    
    container = [[NSMutableArray alloc]init];
    objs = [IngestionMethod query:@"active_ingestion_methods" params:params error:&err];
    for(IngestionMethod *im in objs){
        NSMutableDictionary * obj = [[NSMutableDictionary alloc]init];
        [obj setObject:im.id forKey:@"id"];
        [obj setObject:im.name forKey:@"name"];
        [container addObject:obj];
    }
    jsonData = [NSJSONSerialization dataWithJSONObject:container options:0 error:&err];
    
    dirPaths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
    docsDir = [dirPaths objectAtIndex:0];
    databasePath = [[NSString alloc] initWithString: [docsDir stringByAppendingPathComponent:@"ingestionmethods.dat"]];
    [jsonData writeToFile:databasePath atomically:YES];
    
    
    container = [[NSMutableArray alloc]init];
    objs = [DosageUom query:@"active_dosage_uom" params:params error:&err];
    for(DosageUom *du in objs){
        NSMutableDictionary * obj = [[NSMutableDictionary alloc]init];
        [obj setObject:du.id forKey:@"id"];
        [obj setObject:du.name forKey:@"name"];
        [container addObject:obj];
    }
    jsonData = [NSJSONSerialization dataWithJSONObject:container options:0 error:&err];
    
    dirPaths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
    docsDir = [dirPaths objectAtIndex:0];
    databasePath = [[NSString alloc] initWithString: [docsDir stringByAppendingPathComponent:@"dosageuoms.dat"]];
    [jsonData writeToFile:databasePath atomically:YES];
    
    
    container = [[NSMutableArray alloc]init];
    objs = [TreatmentType query:@"active_treatment_types" params:params error:&err];
    for(TreatmentType *tt in objs){
        NSMutableDictionary * obj = [[NSMutableDictionary alloc]init];
        [obj setObject:tt.id forKey:@"id"];
        [obj setObject:tt.name forKey:@"name"];
        [obj setObject:tt.sortId forKey:@"sort_id"];
        [container addObject:obj];
    }
    jsonData = [NSJSONSerialization dataWithJSONObject:container options:0 error:&err];
    
    dirPaths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
    docsDir = [dirPaths objectAtIndex:0];
    databasePath = [[NSString alloc] initWithString: [docsDir stringByAppendingPathComponent:@"treatmenttypes.dat"]];
    [jsonData writeToFile:databasePath atomically:YES];
    
    container = [[NSMutableArray alloc]init];
    objs = [TreatmentSchedule query:@"active_treatment_schedules" params:params error:&err];
    for(TreatmentSchedule *ts in objs){
        NSMutableDictionary * obj = [[NSMutableDictionary alloc]init];
        [obj setObject:ts.id forKey:@"id"];
        [obj setObject:ts.name forKey:@"name"];
        [obj setObject:ts.sortOrder forKey:@"sort_order"];
        [obj setObject:ts.timesPerDay forKey:@"times_per_day"];
        [container addObject:obj];
    }
    jsonData = [NSJSONSerialization dataWithJSONObject:container options:0 error:&err];
    
    dirPaths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
    docsDir = [dirPaths objectAtIndex:0];
    databasePath = [[NSString alloc] initWithString: [docsDir stringByAppendingPathComponent:@"treatmentschedules.dat"]];
    [jsonData writeToFile:databasePath atomically:YES];
}

-(void)readLabReferenceData {
    
    NSMutableArray *dataArray = [NSMutableArray arrayWithCapacity:1];
    NSArray *directoryPaths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
    NSString *documentsDirectory = [directoryPaths objectAtIndex:0];
    NSString *filePath;
    NSString *jsonString;
    NSArray *jsonArray;

    
    //TestTypes
    filePath = [[NSString alloc] initWithString: [documentsDirectory stringByAppendingPathComponent:@"testtypes.dat"]];
    jsonString = [[NSString alloc] initWithContentsOfFile:filePath encoding:NSUTF8StringEncoding error:nil];
    jsonArray = [NSJSONSerialization JSONObjectWithData:[jsonString dataUsingEncoding:NSUTF8StringEncoding] options:0 error:nil];
    
    for (NSDictionary *dictionary in jsonArray){
        
        TestType *tt = [TestType new];
        
        tt.id = [dictionary objectForKey:@"id"];
        tt.name = [dictionary objectForKey:@"name"];
        //tt.category = [dictionary objectForKey:@"category"];     //RV New lable on API for SymtomsCat, TestTypeCat and medicationCat comented 6/8/15
        tt.testTypeCat = [dictionary objectForKey:@"category"];
        [dataArray addObject:tt];
    }
    
    self.testTypeData = [dataArray copy];
    
    //LabResultStatuses
    filePath = [[NSString alloc] initWithString: [documentsDirectory stringByAppendingPathComponent:@"labresultstatuses.dat"]];
    jsonString = [[NSString alloc] initWithContentsOfFile:filePath encoding:NSUTF8StringEncoding error:nil];
    jsonArray = [NSJSONSerialization JSONObjectWithData:[jsonString dataUsingEncoding:NSUTF8StringEncoding] options:0 error:nil];
    
    
    [dataArray removeAllObjects];
    
    for (NSDictionary *dictionary in jsonArray){
        
        LabResultStat *lrs = [LabResultStat new];
        
        lrs.id = [dictionary objectForKey:@"id"];
        lrs.name = [dictionary objectForKey:@"name"];
        
        [dataArray addObject:lrs];
    }
    
    self.labResultStatusData = [dataArray copy];

}

-(void)writeLabReferenceData {
    NSError *err = nil;
    NSMutableArray *container = [[NSMutableArray alloc]init];
    
    NSDictionary *params = [NSDictionary dictionary];

    NSArray *objs = [TestType query:@"active_test_types" params:params error:&err];
    for(TestType *tt in objs){
        NSMutableDictionary * obj = [[NSMutableDictionary alloc]init];
        [obj setObject:tt.id forKey:@"id"];
        [obj setObject:tt.name forKey:@"name"];
        //[obj setObject:tt.category forKey:@"category"];     //RV New lable on API for SymtomsCat, TestTypeCat and medicationCat comented 6/8/15
        [obj setObject:tt.testTypeCat forKey:@"category"];
        [container addObject:obj];
    }
    NSData *jsonData = [NSJSONSerialization dataWithJSONObject:container options:0 error:&err];
    
    NSArray *dirPaths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
    NSString *docsDir = [dirPaths objectAtIndex:0];
    NSString *databasePath = [[NSString alloc] initWithString: [docsDir stringByAppendingPathComponent:@"testtypes.dat"]];
    [jsonData writeToFile:databasePath atomically:YES];
    
    container = [[NSMutableArray alloc]init];
    objs = [LabResultStat query:@"active_lab_result_statuses" params:params error:&err];
    for(LabResultStat *lrs in objs){
        NSMutableDictionary * obj = [[NSMutableDictionary alloc]init];
        [obj setObject:lrs.id forKey:@"id"];
        [obj setObject:lrs.name forKey:@"name"];
        [container addObject:obj];
    }
    jsonData = [NSJSONSerialization dataWithJSONObject:container options:0 error:&err];
    
    dirPaths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
    docsDir = [dirPaths objectAtIndex:0];
    databasePath = [[NSString alloc] initWithString: [docsDir stringByAppendingPathComponent:@"labresultstatuses.dat"]];
    [jsonData writeToFile:databasePath atomically:YES];    
}

-(void)readJournalReferenceData {

    NSMutableArray *dataArray = [NSMutableArray arrayWithCapacity:1];
    NSArray *directoryPaths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
    NSString *documentsDirectory = [directoryPaths objectAtIndex:0];
    NSString *filePath;
    NSString *jsonString;
    NSArray *jsonArray;
    
    
    //TestTypes
    filePath = [[NSString alloc] initWithString: [documentsDirectory stringByAppendingPathComponent:@"testtypes.dat"]];
  //  filePath = [[NSBundle mainBundle] pathForResource:@"testtypes" ofType:@"dat"];
    jsonString = [[NSString alloc] initWithContentsOfFile:filePath encoding:NSUTF8StringEncoding error:nil];
    jsonArray = [NSJSONSerialization JSONObjectWithData:[jsonString dataUsingEncoding:NSUTF8StringEncoding] options:0 error:nil];
    
    for (NSDictionary *dictionary in jsonArray){
        
        TestType *tt = [TestType new];
        
        tt.id = [dictionary objectForKey:@"id"];
        tt.name = [dictionary objectForKey:@"name"];
        //tt.category = [dictionary objectForKey:@"category"];    //RV New lable on API for SymtomsCat, TestTypeCat and medicationCat comented 6/8/15
        tt.testTypeCat = [dictionary objectForKey:@"category"];
        
        [dataArray addObject:tt];
    }
    
    self.testTypeData = [dataArray copy];

    
    //Moods
    filePath = [[NSString alloc] initWithString: [documentsDirectory stringByAppendingPathComponent:@"moods.dat"]];
   // filePath = [[NSBundle mainBundle] pathForResource:@"moods" ofType:@"dat"];
    jsonString = [[NSString alloc] initWithContentsOfFile:filePath encoding:NSUTF8StringEncoding error:nil];
    jsonArray = [NSJSONSerialization JSONObjectWithData:[jsonString dataUsingEncoding:NSUTF8StringEncoding] options:0 error:nil];
    
    //reset
    [dataArray removeAllObjects];
    
    for (NSDictionary *dictionary in jsonArray){
        
        Mood *m = [Mood new];
        m.id = [dictionary objectForKey:@"id"];
        m.name = [dictionary objectForKey:@"name"];
        
        [dataArray addObject:m];
    }
    //self.moodData = [dataArray copy];

    // Added to sort by Name insensetively - rvera 9/8/14
    NSSortDescriptor *sortDescriptor;
    sortDescriptor = [[NSSortDescriptor alloc] initWithKey:@"name"
                                                 ascending:YES
                                                  selector:@selector(localizedCaseInsensitiveCompare:)];
    NSArray *sortDescriptors = [NSArray arrayWithObject:sortDescriptor];
    NSArray *sortedArray = [dataArray sortedArrayUsingDescriptors:sortDescriptors];
    
    //end to sort - rvera 9/8/14
    
    self.moodData = [sortedArray copy];
    
    
    //Symptoms
    filePath = [[NSString alloc] initWithString: [documentsDirectory stringByAppendingPathComponent:@"symptoms.dat"]];
   // filePath = [[NSBundle mainBundle] pathForResource:@"symptoms" ofType:@"dat"];
    jsonString = [[NSString alloc] initWithContentsOfFile:filePath encoding:NSUTF8StringEncoding error:nil];
    jsonArray = [NSJSONSerialization JSONObjectWithData:[jsonString dataUsingEncoding:NSUTF8StringEncoding] options:0 error:nil];
    
    //reset
    [dataArray removeAllObjects];
    
    for (NSDictionary *dictionary in jsonArray){
        
        Symptom *s = [Symptom new];
        
        s.id = [dictionary objectForKey:@"id"];
        s.name = [dictionary objectForKey:@"name"];
        //s.category = [dictionary objectForKey:@"category"];     //RV New lable on API for SymtomsCat, TestTypeCat and medicationCat comented 6/8/15
        s.symptomCat = [dictionary objectForKey:@"category"];
        s.sortId = [dictionary objectForKey:@"sort_id"];
        
        [dataArray addObject:s];
    }
    
   self.symptomData = [dataArray copy];
   //self.symptomData = [sortedArray copy];



    
    //Abilities
    filePath = [[NSString alloc] initWithString: [documentsDirectory stringByAppendingPathComponent:@"abilities.dat"]];
   // filePath = [[NSBundle mainBundle] pathForResource:@"abilities" ofType:@"dat"];
    jsonString = [[NSString alloc] initWithContentsOfFile:filePath encoding:NSUTF8StringEncoding error:nil];
    jsonArray = [NSJSONSerialization JSONObjectWithData:[jsonString dataUsingEncoding:NSUTF8StringEncoding] options:0 error:nil];
    
    //reset
    [dataArray removeAllObjects];
    
    for (NSDictionary *dictionary in jsonArray){
        
        Ability *ab = [Ability new];
        
        ab.id = [dictionary objectForKey:@"id"];
        ab.name = [dictionary objectForKey:@"name"];
        
        [dataArray addObject:ab];
    }
    
    self.abilityData = [dataArray copy];
}


-(void)writeJournalReferenceData {
    NSError *err = nil;
    NSMutableArray *container = [[NSMutableArray alloc]init];
    
    NSDictionary *params = [NSDictionary dictionary];

    NSArray *objs = [Mood query:@"active_moods" params:params error:&err];
    for(Mood *m in objs){
        NSMutableDictionary * obj = [[NSMutableDictionary alloc]init];
        [obj setObject:m.id forKey:@"id"];
        [obj setObject:m.name forKey:@"name"];
        [container addObject:obj];
    }
    NSData *jsonData = [NSJSONSerialization dataWithJSONObject:container options:0 error:&err];
    
    NSArray *dirPaths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
    NSString *docsDir = [dirPaths objectAtIndex:0];
    NSString *databasePath = [[NSString alloc] initWithString: [docsDir stringByAppendingPathComponent:@"moods.dat"]];
    [jsonData writeToFile:databasePath atomically:YES];
    
    container = [[NSMutableArray alloc]init];
    objs = [Symptom query:@"active_symptoms" params:params error:&err];
    for(Symptom *s in objs){
        NSMutableDictionary * obj = [[NSMutableDictionary alloc]init];
        [obj setObject:s.id forKey:@"id"];
        [obj setObject:s.name forKey:@"name"];
       // [obj setObject:s.category forKey:@"category"];      //RV New lable on API for SymtomsCat, TestTypeCat and medicationCat comented 6/8/15
        [obj setObject:s.symptomCat forKey:@"category"];
        
        [obj setObject:s.sortId forKey:@"sort_id"];
        [container addObject:obj];
    }
    jsonData = [NSJSONSerialization dataWithJSONObject:container options:0 error:&err];
    
    dirPaths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
    docsDir = [dirPaths objectAtIndex:0];
    databasePath = [[NSString alloc] initWithString: [docsDir stringByAppendingPathComponent:@"symptoms.dat"]];
    [jsonData writeToFile:databasePath atomically:YES];
    
    container = [[NSMutableArray alloc]init];
    objs = [Ability query:@"active_abilities" params:params error:&err];
    for(Ability *ab in objs){
        NSMutableDictionary * obj = [[NSMutableDictionary alloc]init];
        [obj setObject:ab.id forKey:@"id"];
        [obj setObject:ab.name forKey:@"name"];
        [container addObject:obj];
    }
    jsonData = [NSJSONSerialization dataWithJSONObject:container options:0 error:&err];
    
    dirPaths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
    docsDir = [dirPaths objectAtIndex:0];
    databasePath = [[NSString alloc] initWithString: [docsDir stringByAppendingPathComponent:@"abilities.dat"]];
    [jsonData writeToFile:databasePath atomically:YES];
    
}

-(void)readSideEffectReferenceData{

    NSMutableArray *dataArray = [NSMutableArray arrayWithCapacity:1];
    NSArray *directoryPaths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
    NSString *documentsDirectory = [directoryPaths objectAtIndex:0];
    NSString *filePath;
    NSString *jsonString;
    NSArray *jsonArray;
    
    
    //SideEffects
    filePath = [[NSString alloc] initWithString: [documentsDirectory stringByAppendingPathComponent:@"sideeffects.dat"]];
    //filePath = [[NSBundle mainBundle] pathForResource:@"sideeffects" ofType:@"dat"];
    jsonString = [[NSString alloc] initWithContentsOfFile:filePath encoding:NSUTF8StringEncoding error:nil];
    jsonArray = [NSJSONSerialization JSONObjectWithData:[jsonString dataUsingEncoding:NSUTF8StringEncoding] options:0 error:nil];
    
    for (NSDictionary *dictionary in jsonArray){
        
        SideEffect *se = [SideEffect new];
        
        se.id = [dictionary objectForKey:@"id"];
        se.name = [dictionary objectForKey:@"name"];
        
        [dataArray addObject:se];
    }

    NSSortDescriptor *sortDescriptor;
    sortDescriptor = [[NSSortDescriptor alloc] initWithKey:@"name"
                                       ascending:YES
                                         selector:@selector(localizedCaseInsensitiveCompare:)];
    NSArray *sortDescriptors = [NSArray arrayWithObject:sortDescriptor];
    NSArray *sortedArray = [dataArray sortedArrayUsingDescriptors:sortDescriptors];
    //cache = [objects sortedArrayUsingDescriptors:sortDescriptors];
    
    
    self.sideEffectData = [sortedArray copy];
    
    

}

-(void)writeSideEffectReferenceData {
    NSError *err = nil;
    NSMutableArray *container = [[NSMutableArray alloc]init];
    
    NSDictionary *params = [NSDictionary dictionary];

    NSArray *objs = [SideEffect query:@"active_side_effects" params:params error:&err];
    for(SideEffect *se in objs){
        NSMutableDictionary * obj = [[NSMutableDictionary alloc]init];
        [obj setObject:se.id forKey:@"id"];
        [obj setObject:se.name forKey:@"name"];
        [container addObject:obj];
    }
    NSData *jsonData = [NSJSONSerialization dataWithJSONObject:container options:0 error:&err];
    
    NSArray *dirPaths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
    NSString *docsDir = [dirPaths objectAtIndex:0];
    NSString *databasePath = [[NSString alloc] initWithString: [docsDir stringByAppendingPathComponent:@"sideeffects.dat"]];
    [jsonData writeToFile:databasePath atomically:YES];
    
}

-(BOOL)copyDefaultReferenceData {
    NSArray *paths = [[NSArray alloc]initWithObjects:@"sideeffects",@"abilities",@"symptoms",@"moods",@"labresultstatuses",@"testtypes",@"treatmentschedules",@"treatmenttypes",@"dosageuoms",@"ingestionmethods",@"medications",@"missingtreatmentreasons", nil];
    
    NSArray *dirPaths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
    NSString *docsDir = [dirPaths objectAtIndex:0];
    
    
//   *****         -  iOs 8 cleanup svaz 2/4/2015    
//    THIS ONLY WORKS IF THE .dat files exist in the project directory else it will crash!!!!!!
//
    for (NSString *path in paths){
        NSString *databasePath = [[NSString alloc] initWithString: [docsDir stringByAppendingPathComponent:[path stringByAppendingString:@".dat"]]];
        NSFileManager *fmngr = [[NSFileManager alloc] init];
        NSString *filePath = [[NSBundle mainBundle] pathForResource:[path stringByAppendingString:@".dat"] ofType:nil];
        NSError *error = nil;
        if (path) {
            if(![fmngr copyItemAtPath:filePath toPath:databasePath error:&error]) {
                // handle the error
                NSLog(@"Error creating the database: %@", [error description]);
                return false;
            }
        }
        else NSLog(@"path is nil");
    }
    return true;
}

-(BOOL)finishedLoadingExacerbationData {
    if(self.symptomData.count == 0)return false;
    return true;
}
-(BOOL)finishedLoadingSideEffectData {
    if(self.sideEffectData.count == 0)return false;
    return true;
}

-(BOOL)finishedLoadingLabReferenceData {
    if (self.labResultStatusData.count == 0 ||
        self.testTypeData.count == 0)
        return false;
    
    return true;
}

-(BOOL)finishedLoadingJournalReferenceData {
    if (self.moodData.count == 0 ||
        self.abilityData.count == 0 ||
        self.symptomData.count == 0)
        return false;
    return true;
}

-(BOOL)finishedLoadingReferenceData{
    if (self.treatmentScheduleData.count == 0 ||
        self.treatmentTypeData.count == 0 ||
        self.medicationData.count == 0 ||
        self.ingestionMethodData.count == 0 ||
        self.dosageUomData.count == 0 ||
        self.missingTreatmentReasonData.count == 0)
        return false;
    
    return true;
}
-(BOOL)referenceFilesExist {
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSArray *paths = [[NSArray alloc]initWithObjects:@"sideeffects",@"abilities",@"symptoms",@"moods",@"labresultstatuses",@"testtypes",@"treatmentschedules",@"treatmenttypes",@"dosageuoms",@"ingestionmethods",@"medications",@"missingtreatmentreasons", nil];
    
    NSArray *dirPaths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
    NSString *docsDir = [dirPaths objectAtIndex:0];
    
    for(NSString *path in paths){
        if ([fileManager fileExistsAtPath:[docsDir stringByAppendingPathComponent:[path stringByAppendingString:@".dat"]]]){
            //NSLog(@"Path to %@ data exists",path);
        }
        else return false;
    }
    //NSLog(@"All Files Exist, Sanity Verified");
    return true;
}
-(BOOL)finishedLoadingAllReferenceData {
    if([self finishedLoadingJournalReferenceData] &&
       [self finishedLoadingLabReferenceData] &&
       [self finishedLoadingReferenceData] &&
       [self finishedLoadingSideEffectData])
        return true;
    return false;
}
-(float)referenceLoadingProgress {
    float count = 0.0f;
    if ([self finishedLoadingJournalReferenceData]) count+= 0.25f;
    if ([self finishedLoadingLabReferenceData]) count+= 0.25f;
    if ([self finishedLoadingReferenceData]) count+= 0.25f;
    if ([self finishedLoadingSideEffectData]) count+= 0.25f;
    return count;
}

-(void)checkAndUpdateReferenceData {
    
    NSError *e = nil;
  //  NSDictionary *params = [[NSDictionary alloc]initWithObjects:[NSArray arrayWithObject:[[ConfigurationManager sharedManager] appID]] forKeys:[NSArray arrayWithObject:@"id"]];
 //   Application *s = (Application *)[[Application query:@"exact_match" params:params error:&e] objectAtIndex:0];
    Setting *s = (Setting *)[[Setting query:@"my_app_setting" params:nil error:&e] objectAtIndex:0];
    
    if (e) {
        return;
    }
    
    NSUserDefaults *prefs = [NSUserDefaults standardUserDefaults];
    
    
    NSLog(@"Prefs Date:%@", [prefs objectForKey:@"ref_data_lab_results_updated_on"]);
    NSLog(@"Settings Date:%@", s.refDataLabResultsUpdatedOn);
    
    
    if([(NSDate *)[prefs objectForKey:@"ref_data_treatment_updated_on"] compare:s.refDataTreatmentUpdatedOn] == NSOrderedAscending){
        [self writeTreatmentReferenceData];
        [prefs setObject:s.refDataTreatmentUpdatedOn forKey:@"ref_data_treatment_updated_on"];
    }
    if([(NSDate *)[prefs objectForKey:@"ref_data_journals_updated_on"] compare:s.refDataJournalsUpdatedOn] == NSOrderedAscending){
        [self writeJournalReferenceData];
        [prefs setObject:s.refDataJournalsUpdatedOn forKey:@"ref_data_journals_updated_on"];
    }
    if([(NSDate *)[prefs objectForKey:@"ref_data_lab_results_updated_on"] compare:s.refDataLabResultsUpdatedOn] == NSOrderedAscending){
        [self writeLabReferenceData];
        [prefs setObject:s.refDataLabResultsUpdatedOn forKey:@"ref_data_lab_results_updated_on"];
    }
    if([(NSDate *)[prefs objectForKey:@"ref_data_side_effects_updated_on"] compare:s.refDataSideEffectsUpdatedOn] == NSOrderedAscending){
        [self writeSideEffectReferenceData];
        [prefs setObject:s.refDataSideEffectsUpdatedOn forKey:@"ref_data_side_effects_updated_on"];
    }
    
    [prefs synchronize];
    
}
-(void)setUpReferenceDates {
    NSDateFormatter *f = [[NSDateFormatter alloc]init];
    f.dateFormat = @"yyyy-MM-dd";
    NSArray *arr = [[NSArray alloc]initWithObjects:@"ref_data_treatment_updated_on",@"ref_data_journals_updated_on",@"ref_data_lab_results_updated_on",@"ref_data_side_effects_updated_on", nil];
    NSDate *date = [f dateFromString:LAST_REFERENCE_UPDATE];
    NSUserDefaults *prefs = [NSUserDefaults standardUserDefaults];
    for(NSString *str in arr){
        [prefs setObject:date forKey:str];
    }
    [prefs synchronize];
}

@end
